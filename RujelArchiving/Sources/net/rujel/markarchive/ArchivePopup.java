//ArchivePopup.java : Class file for WO Component 'ArchivePopup'

/*
 * Copyright (c) 2008, Gennady & Michael Kushnir
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 * 	•	Redistributions of source code must retain the above copyright notice, this
 * 		list of conditions and the following disclaimer.
 * 	•	Redistributions in binary form must reproduce the above copyright notice,
 * 		this list of conditions and the following disclaimer in the documentation
 * 		and/or other materials provided with the distribution.
 * 	•	Neither the name of the RUJEL nor the names of its contributors may be used
 * 		to endorse or promote products derived from this software without specific
 * 		prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package net.rujel.markarchive;

import java.util.Enumeration;
import java.util.logging.Logger;

import net.rujel.reusables.WOLogLevel;

import com.webobjects.appserver.*;
import com.webobjects.eocontrol.*;
import com.webobjects.foundation.*;

// Generated by the WOLips Templateengine Plug-in at Nov 19, 2008 2:10:06 PM
public class ArchivePopup extends com.webobjects.appserver.WOComponent {
    public ArchivePopup(WOContext context) {
        super(context);
        reason = (String)session().objectForKey("MarkArchive.reason");
    }
	protected static Logger logger = Logger.getLogger("rujel.markarchive");
   
    public WOComponent returnPage;
    public EOEnterpriseObject obj;
    protected NSMutableArray keys;
    public NSDictionary presentKeys;
    public NSArray archives;
    public NSMutableDictionary newValues;
    public Boolean changeable;
    
    public MarkArchive archive;
    public MarkArchive archItem;
    public String keyItem;
    
    public String presenter;
    public Object initData;
    public Boolean noEdit;

    public String reason;
	public String description;
    
	public NSArray keys() {
		return keys;
	}

	public void setKeys(NSArray keys) {
		this.keys = keys.mutableClone();
	}
	
	public void reset() {
		super.reset();
		obj = null;
		keys = null;
		presentKeys = null;
		archives = null;
		newValues = null;
		changeable = null;
		archive = null;
		archItem = null;
		keyItem = null;
		initData = null;
		reason = (String)session().objectForKey("MarkArchive.reason");
		description = null;
	}
	
	public void setIdentifierDictionary(NSDictionary identifierDict) {
		reset();
		if(identifierDict == null) {
			archives = null;
			return;
		}
		String entityName = (String)identifierDict.valueForKey("entityName");
		EOEditingContext ec = (EOEditingContext)identifierDict.valueForKey("editingContext");
		EOQualifier qual = MarkArchive.archiveQualifier(entityName, identifierDict, ec);
		EOSortOrdering so = EOSortOrdering.sortOrderingWithKey(
									"timestamp", EOSortOrdering.CompareAscending);
		EOFetchSpecification fs = new EOFetchSpecification("MarkArchive",qual,new NSArray(so));
		archives = ec.objectsWithFetchSpecification(fs);
		processArchives();
		if(noEdit != null && noEdit.booleanValue())
			changeable = Boolean.FALSE;
		else
			changeable = (Boolean)session().valueForKeyPath("readAccess.edit." + entityName);
		if(initData == null)
			initData = identifierDict;
	}
	
	public void setObject(EOEnterpriseObject eo) {
		reset();
		obj = eo;
		if(eo == null) {
			archives = null;
			return;
		}
		archives = MarkArchive.archivesForObject(eo);
		processArchives();
		if(noEdit != null && noEdit.booleanValue())
			changeable = Boolean.FALSE;
		else
			changeable = (Boolean)session().valueForKeyPath("readAccess.edit." + obj.entityName());
	}
	
	protected void processArchives() {
		if(keys == null)
			return;
			//keys = new NSMutableArray();
		if(archives != null && archives.count() > 0) {
			Enumeration enu = archives.objectEnumerator();
			while (enu.hasMoreElements()) {
				MarkArchive ma = (MarkArchive) enu.nextElement();
				Enumeration maKeys = ma.getArchiveDictionary().keyEnumerator();
				while (maKeys.hasMoreElements()) {
					String key = (String) maKeys.nextElement();
					if(key.equals(MarkArchive.REASON_KEY))
						continue;
					if(!keys.containsObject(key))
						keys.addObject(key);
				}
			}
		} else if(keys == null && obj != null) {
			keys = obj.attributeKeys().mutableClone();
		}
	}
	
	public NSMutableDictionary newValues() {
		if(newValues == null && changeable) {
			newValues = new NSMutableDictionary();
			Enumeration enu = keys.objectEnumerator();
			while (enu.hasMoreElements()) {
				String key = (String) enu.nextElement();
				newValues.takeValueForKey(obj.valueForKey(key), key);
			}
		}
		return newValues;
	}
	
	public String currKey() {
		if(presentKeys == null || keyItem == null)
			return keyItem;
		String value = (String)presentKeys.valueForKey(keyItem); 
		return (value == null)?keyItem:value;
	}
	
	public String currValue() {
		if(keyItem == null)
			return null;
		if(archItem != null)
			return archItem.getArchiveValueForKey(keyItem);
		if(newValues() != null)
			return (String)newValues().valueForKey(keyItem);
		return null;
	}
	
	public void setCurrValue(String value) {
		if(newValues == null)
			newValues = new NSMutableDictionary(value,keyItem);
		else
			newValues.takeValueForKey(value, keyItem);
	}
	
	public WOActionResults save() {
		if(archive != null) {
			EOEditingContext ec = archive.editingContext();
			try {
				ec.lock();
				archive.setReason(reason);
				ec.saveChanges();
	        	session().removeObjectForKey("MarkArchive.reason");
				session().setObjectForKey(initData, "objectSaved");
				session().valueForKeyPath("modules.objectSaved");
				session().removeObjectForKey("objectSaved");
				logger.log(WOLogLevel.EDITING,"Changes are saved and archived",
						new Object[] {session(),archive,initData});
			} catch (Exception e) {
				session().takeValueForKey(e.getMessage(), "message");
				session().setObjectForKey(reason, "MarkArchive.reason");
				logger.log(WOLogLevel.INFO,"Failed to save and archive changes",
						new Object[] {session(),archive,initData,e});
				ec.revert();
			} finally {
				ec.unlock();
			}
		}
		returnPage.ensureAwakeInContext(context());
		return returnPage;
	}
	
	public String showReason() {
		if(archItem == null)
			return null;
		else if (archItem.reason() == null)
			return null;
		String reas = archItem.reason();
		if(reas.length() < 10)
			return reas;
		StringBuffer result = new StringBuffer("<div style=\"width:5em;\" title=\"");
		result.append(WOMessage.stringByEscapingHTMLAttributeValue(reas));
		result.append("\" onclick=\"alert(this.title);\">");
		result.append(reas.substring(0, 8)).append("...</div>");
		return result.toString();
	}
	
	public boolean disableSave() {
		return (reason == null || reason.length() == 0);
	}
	
    public void appendToResponse(WOResponse aResponse, WOContext aContext) {
    	if(initData != null)
    		session().setObjectForKey(initData, "readAccess");
    	super.appendToResponse(aResponse, aContext);
    	session().removeObjectForKey("readAccess");
    }
}